/*
Cube Demo - adapted from the program written by Keith Ditchburn, 2008
*/

// Exclude rarely-used stuff from Windows headers
#define VC_EXTRALEAN

// Library header files
#include <windows.h>
#include <assert.h>

/* The resources header is automatically generated by the resource editor
To see and edit the resources select the resource view tab in the side window */
#include "resource.h"
#include "graphics.h"

CGraphics graphics;

// Since this file is a C file I am storing the instance in a global
HINSTANCE gInst=0; 

// Forward declarations of functions included in this code module:
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

/*
	This is the main entry point of any Windows API program (like main() in non windows coding)
	It is called with instance handles, the command line and a flag specifying how the app
	window should initially be shown e.g. maximised, minimised

	In this function we need to create our main window and enter a message loop.
	
	To create our window we first of all create a window class (here meaning type not C++ class) 
	by filling out a structure and registering it. Next the window itself is created from this class 
	using CreateWindow. 
	
	There are a lot of flags and parameters (see site for details) but the most important one is the lpfnWndProc member
	of the class which is the address of the function you wish Windows to send messages to

	The message loop here has been altered so we can render our demo as fast as possible. This is achieved by 
	updating our demo whenever there is no message for our window
*/
int 
APIENTRY WinMain (
	HINSTANCE hInstance,
	HINSTANCE, // hPrevInstance,
	LPSTR, // lpCmdLine,
	int nCmdShow)
{
	// Create and register a window class
	WNDCLASSEX wcex;

	wcex.cbSize			= sizeof(WNDCLASSEX);
	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CUBEDEMO));
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_CUBEDEMO);
	wcex.lpszClassName	= "MyWindowClass";
	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	RegisterClassEx(&wcex);

	// Store program instance handle in a global variable as it is needed in the WndProc
	gInst = hInstance; 

	// Create the main window
	HWND hWnd = CreateWindow("MyWindowClass", "Cube Demo", WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, 800, 600, NULL, NULL, hInstance, NULL);
	if (!hWnd)
		return 0;

	// Create and initialise our graphics class
	if (!graphics.Initialise(hWnd))
		return 0;

	// We must remember to show our window!
	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);	

	/* Enter our program loop - this loop continues until the program exits
	For maximum performance whenever the application is idle (not getting messages) 
	render our scene (being badly behaved!) */
    MSG msg;
    ZeroMemory( &msg, sizeof(msg) );
    while( msg.message!=WM_QUIT )
    {
        if( PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else 		
		{
			if (!graphics.Render())
			{
				// a problem occured so force a close down
				PostQuitMessage(0);
			}
		}
    }

	return (int) msg.wParam;
}

/* 
Message handler for the main window
This function is called by thw Windows API when there is a message for our window
It knows to call this function as we specified it when filling in aour window class structure
Each message has some data associated with it. This data is held in the wParam and lParam variables
Because the type of data can bequite different depending on the message these variables can also be packed
with data. e.g. the low word of the wParam can be one value and the high word another
*/
#define EYE_MOVE_AMOUNT 5.0

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDM_ABOUT:
					DialogBox(gInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
					break;
				case IDM_EXIT:
					DestroyWindow(hWnd);
					break;
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		case WM_KEYDOWN :
			switch(wParam)
			{
				case ' ' : 
					rotateEnable = !rotateEnable;
					break;
				case '1' : 
					graphics.MoveEye(-EYE_MOVE_AMOUNT,0,0);
					break;
				case '2' :
					graphics.MoveEye(+EYE_MOVE_AMOUNT,0,0);
					break;
				case '3' : 
					graphics.MoveEye(0,-EYE_MOVE_AMOUNT,0);
					break;
				case '4' :
					graphics.MoveEye(0,+EYE_MOVE_AMOUNT,0);
					break;
				case '5' : 
					graphics.MoveEye(0,0,-EYE_MOVE_AMOUNT);
					break;
				case '6' :
					graphics.MoveEye(0,0,+EYE_MOVE_AMOUNT);
					break;
			}
			break;
	
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
	}

	// If we do handle a message we should return 0
	return 0;
}

/* 
Message handler for about box.
Dialog box message handlers are very similar to main window ones but differ in a couple of ways:
Firstly you need to return true if a message is handled and false if is not
Secondly there is a special message WM_INITDIALOG that you must handle. If you have controls on 
your dialog this is thg place to fill in their values
*/


INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	switch (message)
	{
		case WM_INITDIALOG:
			return (INT_PTR)TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
			{
				EndDialog(hDlg, LOWORD(wParam));
				return (INT_PTR)TRUE;
			}
			break;
	}
	return (INT_PTR)FALSE;
}
