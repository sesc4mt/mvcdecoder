<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >File I/O</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><a href="index.html"
    ><strong
      >Contents</strong
      ></a
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem</a
    ></li
  ><li
  ><a href="fixed.html"
    >Fixed</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="platform.html"
    >Platform-specific</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="transformations.html"
    >Transformations</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><a href="index.html#addons"
    ><strong
      >Addons</strong
      ></a
    ></li
  ><li
  ><a href="audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="image.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function on_search(index, control) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == control.keywords[index]) {
            break;
        }
    }
    location.href = search_urls[i];
}
</script>Search<br /> <input type="text" name="q" id="q" size="15" autocomplete="off" /><br /><script type="text/javascript"> new autosuggest("q", search_index, null, on_search); </script>
</div>

</td>
<td class="content">


<h1 class="title"
    >File I/O</h1
    ><div id="TOC"
    ><ul
      ><li
	><a href="#allegro_file"
	  >ALLEGRO_FILE</a
	  ></li
	><li
	><a href="#allegro_file_interface"
	  >ALLEGRO_FILE_INTERFACE</a
	  ></li
	><li
	><a href="#allegro_seek"
	  >ALLEGRO_SEEK</a
	  ></li
	><li
	><a href="#al_fopen"
	  >al_fopen</a
	  ></li
	><li
	><a href="#al_fclose"
	  >al_fclose</a
	  ></li
	><li
	><a href="#al_fread"
	  >al_fread</a
	  ></li
	><li
	><a href="#al_fwrite"
	  >al_fwrite</a
	  ></li
	><li
	><a href="#al_fflush"
	  >al_fflush</a
	  ></li
	><li
	><a href="#al_ftell"
	  >al_ftell</a
	  ></li
	><li
	><a href="#al_fseek"
	  >al_fseek</a
	  ></li
	><li
	><a href="#al_feof"
	  >al_feof</a
	  ></li
	><li
	><a href="#al_ferror"
	  >al_ferror</a
	  ></li
	><li
	><a href="#al_fungetc"
	  >al_fungetc</a
	  ></li
	><li
	><a href="#al_fsize"
	  >al_fsize</a
	  ></li
	><li
	><a href="#al_fgetc"
	  >al_fgetc</a
	  ></li
	><li
	><a href="#al_fputc"
	  >al_fputc</a
	  ></li
	><li
	><a href="#al_fread16le"
	  >al_fread16le</a
	  ></li
	><li
	><a href="#al_fread16be"
	  >al_fread16be</a
	  ></li
	><li
	><a href="#al_fwrite16le"
	  >al_fwrite16le</a
	  ></li
	><li
	><a href="#al_fwrite16be"
	  >al_fwrite16be</a
	  ></li
	><li
	><a href="#al_fread32le"
	  >al_fread32le</a
	  ></li
	><li
	><a href="#al_fread32be"
	  >al_fread32be</a
	  ></li
	><li
	><a href="#al_fwrite32le"
	  >al_fwrite32le</a
	  ></li
	><li
	><a href="#al_fwrite32be"
	  >al_fwrite32be</a
	  ></li
	><li
	><a href="#al_fgets"
	  >al_fgets</a
	  ></li
	><li
	><a href="#al_fget_ustr"
	  >al_fget_ustr</a
	  ></li
	><li
	><a href="#al_fputs"
	  >al_fputs</a
	  ></li
	><li
	><a href="#standard-io-specific-routines"
	  >Standard I/O specific routines</a
	  ><ul
	  ><li
	    ><a href="#al_fopen_fd"
	      >al_fopen_fd</a
	      ></li
	    ><li
	    ><a href="#al_make_temp_file"
	      >al_make_temp_file</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#alternative-file-streams"
	  >Alternative file streams</a
	  ><ul
	  ><li
	    ><a href="#al_set_new_file_interface"
	      >al_set_new_file_interface</a
	      ></li
	    ><li
	    ><a href="#al_set_standard_file_interface"
	      >al_set_standard_file_interface</a
	      ></li
	    ><li
	    ><a href="#al_get_new_file_interface"
	      >al_get_new_file_interface</a
	      ></li
	    ></ul
	  ></li
	></ul
      ></div
    ><p
    >These functions are declared in the main Allegro header file:</p
    ><pre
    ><code
      >#include &lt;allegro5/allegro.h&gt;
</code
      ></pre
    ><div id="allegro_file"
    ><h1
      ><a href="#TOC"
	>ALLEGRO_FILE</a
	></h1
      ><pre
      ><code
	>typedef struct ALLEGRO_FILE ALLEGRO_FILE;
</code
	></pre
      ><p
      >An opaque object representing an open file. This could be a real file on disk or a virtual file.</p
      ></div
    ><div id="allegro_file_interface"
    ><h1
      ><a href="#TOC"
	>ALLEGRO_FILE_INTERFACE</a
	></h1
      ><pre
      ><code
	>typedef struct ALLEGRO_FILE_INTERFACE
</code
	></pre
      ><p
      >A structure containing function pointers to handle a type of &quot;file&quot;, real or virtual. See the full discussion in <a href="file.html#al_set_new_file_interface"
	>al_set_new_file_interface</a
	>.</p
      ><p
      >The fields are:</p
      ><pre
      ><code
	>ALLEGRO_FILE* (*fi_fopen)(const char *path, const char *mode);
void          (*fi_fclose)(ALLEGRO_FILE *handle);
size_t        (*fi_fread)(ALLEGRO_FILE *f, void *ptr, size_t size);
size_t        (*fi_fwrite)(ALLEGRO_FILE *f, const void *ptr, size_t size);
bool          (*fi_fflush)(ALLEGRO_FILE *f);
int64_t       (*fi_ftell)(ALLEGRO_FILE *f);
bool          (*fi_fseek)(ALLEGRO_FILE *f, int64_t offset, int whence);
bool          (*fi_feof)(ALLEGRO_FILE *f);
bool          (*fi_ferror)(ALLEGRO_FILE *f);
int           (*fi_fungetc)(ALLEGRO_FILE *f, int c);
off_t         (*fi_fsize)(ALLEGRO_FILE *f);
</code
	></pre
      ></div
    ><div id="allegro_seek"
    ><h1
      ><a href="#TOC"
	>ALLEGRO_SEEK</a
	></h1
      ><pre
      ><code
	>typedef enum ALLEGRO_SEEK
</code
	></pre
      ><ul
      ><li
	>ALLEGRO_SEEK_SET - Seek to pos from beginning of file</li
	><li
	>ALLEGRO_SEEK_CUR - Seek to pos from curent position</li
	><li
	>ALLEGRO_SEEK_END - Seek to pos from end of file</li
	></ul
      ></div
    ><div id="al_fopen"
    ><h1
      ><a href="#TOC"
	>al_fopen</a
	></h1
      ><pre
      ><code
	>ALLEGRO_FILE *al_fopen(const char *path, const char *mode)
</code
	></pre
      ><p
      >Creates and opens a file (real or virtual) given the path and mode. The current file interface is used to open the file.</p
      ><p
      >'path' - the path to open</p
      ><p
      >'mode' - mode to open the entry in (&quot;r&quot;, &quot;w&quot;, etc.)</p
      ><p
      >Depending on the stream type and the mode string, files may be opened in &quot;text&quot; mode. The handling of newlines is particularly important. For example, using the default stdio-based streams on DOS and Windows platforms, where the native end-of-line terminators are CR+LF sequences, a call to <a href="file.html#al_fgetc"
	>al_fgetc</a
	> may return just one character ('\n') where there were two bytes (CR+LF) in the file. When writing out '\n', two bytes would be written instead. (As an aside, '\n' is not defined to be equal to LF either.)</p
      ><p
      >Newline translations can be useful for text files but is disastrous for binary files. To avoid this behaviour you need to open file streams in binary mode by using a mode argument containing a &quot;b&quot;, e.g. &quot;rb&quot;, &quot;wb&quot;.</p
      ><p
      >See also: <a href="file.html#al_set_new_file_interface"
	>al_set_new_file_interface</a
	>.</p
      ></div
    ><div id="al_fclose"
    ><h1
      ><a href="#TOC"
	>al_fclose</a
	></h1
      ><pre
      ><code
	>void al_fclose(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Close the given file.</p
      ></div
    ><div id="al_fread"
    ><h1
      ><a href="#TOC"
	>al_fread</a
	></h1
      ><pre
      ><code
	>size_t al_fread(ALLEGRO_FILE *f, void *ptr, size_t size)
</code
	></pre
      ><p
      >Read 'size' bytes into 'ptr' from entry 'fp'</p
      ><p
      >Return number of bytes actually read.</p
      ></div
    ><div id="al_fwrite"
    ><h1
      ><a href="#TOC"
	>al_fwrite</a
	></h1
      ><pre
      ><code
	>size_t al_fwrite(ALLEGRO_FILE *f, const void *ptr, size_t size)
</code
	></pre
      ><p
      >Write 'size' bytes from 'ptr' into file 'fp'</p
      ><p
      >Return number of bytes actually written or 0 on error.</p
      ><p
      >Does not distinguish between EOF and other errors. Use <a href="file.html#al_feof"
	>al_feof</a
	> and <a href="file.html#al_ferror"
	>al_ferror</a
	> to tell them apart.</p
      ></div
    ><div id="al_fflush"
    ><h1
      ><a href="#TOC"
	>al_fflush</a
	></h1
      ><pre
      ><code
	>bool al_fflush(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Flush any pending writes to 'fp' to disk.</p
      ><p
      >Returns true on success, false otherwise, and errno is set to indicate the error.</p
      ><p
      >See also: <a href="state.html#al_get_errno"
	>al_get_errno</a
	></p
      ></div
    ><div id="al_ftell"
    ><h1
      ><a href="#TOC"
	>al_ftell</a
	></h1
      ><pre
      ><code
	>int64_t al_ftell(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Returns the current position in file, or -1 on error. errno is set to indicate the error.</p
      ><p
      >On some platforms this function may not support large files.</p
      ><p
      >See also: <a href="state.html#al_get_errno"
	>al_get_errno</a
	></p
      ></div
    ><div id="al_fseek"
    ><h1
      ><a href="#TOC"
	>al_fseek</a
	></h1
      ><pre
      ><code
	>bool al_fseek(ALLEGRO_FILE *f, int64_t offset, int whence)
</code
	></pre
      ><p
      >Seek to 'offset' in file based on 'whence'.</p
      ><p
      >'whence' can be:</p
      ><ul
      ><li
	>ALLEGRO_SEEK_SET - Seek from beggining of file</li
	><li
	>ALLEGRO_SEEK_CUR - Seek from current position</li
	><li
	>ALLEGRO_SEEK_END - Seek from end of file</li
	></ul
      ><p
      >Returns true on success, false on failure and errno is set to indicate the error.</p
      ><p
      >On some platforms this function may not support large files.</p
      ><p
      >See also: <a href="state.html#al_get_errno"
	>al_get_errno</a
	></p
      ></div
    ><div id="al_feof"
    ><h1
      ><a href="#TOC"
	>al_feof</a
	></h1
      ><pre
      ><code
	>bool al_feof(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Returns true if the end-of-file indicator has been set on the file, i.e. we have attempted to read <em
	>past</em
	> the end of the file.</p
      ><p
      >This does <em
	>not</em
	> return true if we simply are at the end of the file. The following code correctly reads two bytes, even when the file contains exactly two bytes:</p
      ><pre
      ><code
	>int b1 = al_fgetc(f);
int b2 = al_fgetc(f);
if (al_feof(f)) {
   /* At least one byte was unsuccessfully read. */
   report_error();
}
</code
	></pre
      ><p
      >See also: <a href="file.html#al_ferror"
	>al_ferror</a
	></p
      ></div
    ><div id="al_ferror"
    ><h1
      ><a href="#TOC"
	>al_ferror</a
	></h1
      ><pre
      ><code
	>bool al_ferror(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Returns true if there was some sort of previous error.</p
      ><p
      >See also: <a href="file.html#al_feof"
	>al_feof</a
	></p
      ></div
    ><div id="al_fungetc"
    ><h1
      ><a href="#TOC"
	>al_fungetc</a
	></h1
      ><pre
      ><code
	>int al_fungetc(ALLEGRO_FILE *f, int c)
</code
	></pre
      ><p
      >Ungets a single byte from a file. Does not write to file, it only places the char back into the entry's buffer.</p
      ><p
      >See also: <a href="file.html#al_fgetc"
	>al_fgetc</a
	>, <a href="state.html#al_get_errno"
	>al_get_errno</a
	></p
      ></div
    ><div id="al_fsize"
    ><h1
      ><a href="#TOC"
	>al_fsize</a
	></h1
      ><pre
      ><code
	>int64_t al_fsize(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Return the size of the file, if it can be determined, or -1 otherwise.</p
      ></div
    ><div id="al_fgetc"
    ><h1
      ><a href="#TOC"
	>al_fgetc</a
	></h1
      ><pre
      ><code
	>int al_fgetc(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Read and return next byte in entry 'f'. Returns EOF on end of file or if an error occurred.</p
      ><p
      >See also: <a href="file.html#al_fungetc"
	>al_fungetc</a
	></p
      ></div
    ><div id="al_fputc"
    ><h1
      ><a href="#TOC"
	>al_fputc</a
	></h1
      ><pre
      ><code
	>int al_fputc(ALLEGRO_FILE *f, int c)
</code
	></pre
      ><p
      >Write a single byte to entry.</p
      ><p
      >Parameters:</p
      ><ul
      ><li
	>c - byte value to write</li
	><li
	>f - entry to write to</li
	></ul
      ><p
      >Returns: EOF on error</p
      ></div
    ><div id="al_fread16le"
    ><h1
      ><a href="#TOC"
	>al_fread16le</a
	></h1
      ><pre
      ><code
	>int16_t al_fread16le(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Reads a 16-bit word in little-endian format (LSB first).</p
      ><p
      >On success, returns the 16-bit word. On failure, returns EOF (-1). Since -1 is also a valid return value, use <a href="file.html#al_feof"
	>al_feof</a
	> to check if the end of the file was reached prematurely, or <a href="file.html#al_ferror"
	>al_ferror</a
	> to check if an error occurred.</p
      ><p
      >See also: <a href="file.html#al_fread16be"
	>al_fread16be</a
	></p
      ></div
    ><div id="al_fread16be"
    ><h1
      ><a href="#TOC"
	>al_fread16be</a
	></h1
      ><pre
      ><code
	>int16_t al_fread16be(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Reads a 16-bit word in big-endian format (MSB first).</p
      ><p
      >On success, returns the 16-bit word. On failure, returns EOF (-1). Since -1 is also a valid return value, use <a href="file.html#al_feof"
	>al_feof</a
	> to check if the end of the file was reached prematurely, or <a href="file.html#al_ferror"
	>al_ferror</a
	> to check if an error occurred.</p
      ><p
      >See also: <a href="file.html#al_fread16le"
	>al_fread16le</a
	></p
      ></div
    ><div id="al_fwrite16le"
    ><h1
      ><a href="#TOC"
	>al_fwrite16le</a
	></h1
      ><pre
      ><code
	>size_t al_fwrite16le(ALLEGRO_FILE *f, int16_t w)
</code
	></pre
      ><p
      >Writes a 16-bit word in little-endian format (LSB first).</p
      ><p
      >Returns the number of bytes written: 2 on success, less than 2 on an error.</p
      ><p
      >See also: <a href="file.html#al_fwrite16be"
	>al_fwrite16be</a
	></p
      ></div
    ><div id="al_fwrite16be"
    ><h1
      ><a href="#TOC"
	>al_fwrite16be</a
	></h1
      ><pre
      ><code
	>size_t al_fwrite16be(ALLEGRO_FILE *f, int16_t w)
</code
	></pre
      ><p
      >Writes a 16-bit word in big-endian format (MSB first).</p
      ><p
      >Returns the number of bytes written: 2 on success, less than 2 on an error.</p
      ><p
      >See also: <a href="file.html#al_fwrite16le"
	>al_fwrite16le</a
	></p
      ></div
    ><div id="al_fread32le"
    ><h1
      ><a href="#TOC"
	>al_fread32le</a
	></h1
      ><pre
      ><code
	>int32_t al_fread32le(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Reads a 32-bit word in little-endian format (LSB first).</p
      ><p
      >On success, returns the 32-bit word. On failure, returns EOF (-1). Since -1 is also a valid return value, use <a href="file.html#al_feof"
	>al_feof</a
	> to check if the end of the file was reached prematurely, or <a href="file.html#al_ferror"
	>al_ferror</a
	> to check if an error occurred.</p
      ><p
      >See also: <a href="file.html#al_fread32be"
	>al_fread32be</a
	></p
      ></div
    ><div id="al_fread32be"
    ><h1
      ><a href="#TOC"
	>al_fread32be</a
	></h1
      ><pre
      ><code
	>int32_t al_fread32be(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Read a 32-bit word in big-endian format (MSB first).</p
      ><p
      >On success, returns the 32-bit word. On failure, returns EOF (-1). Since -1 is also a valid return value, use <a href="file.html#al_feof"
	>al_feof</a
	> to check if the end of the file was reached prematurely, or <a href="file.html#al_ferror"
	>al_ferror</a
	> to check if an error occurred.</p
      ><p
      >See also: <a href="file.html#al_fread32le"
	>al_fread32le</a
	></p
      ></div
    ><div id="al_fwrite32le"
    ><h1
      ><a href="#TOC"
	>al_fwrite32le</a
	></h1
      ><pre
      ><code
	>size_t al_fwrite32le(ALLEGRO_FILE *f, int32_t l)
</code
	></pre
      ><p
      >Writes a 32-bit word in little-endian format (LSB first).</p
      ><p
      >Returns the number of bytes written: 4 on success, less than 4 on an error.</p
      ><p
      >See also: <a href="file.html#al_fwrite32be"
	>al_fwrite32be</a
	></p
      ></div
    ><div id="al_fwrite32be"
    ><h1
      ><a href="#TOC"
	>al_fwrite32be</a
	></h1
      ><pre
      ><code
	>size_t al_fwrite32be(ALLEGRO_FILE *f, int32_t l)
</code
	></pre
      ><p
      >Writes a 32-bit word in big-endian format (MSB first).</p
      ><p
      >Returns the number of bytes written: 4 on success, less than 4 on an error.</p
      ><p
      >See also: <a href="file.html#al_fwrite32le"
	>al_fwrite32le</a
	></p
      ></div
    ><div id="al_fgets"
    ><h1
      ><a href="#TOC"
	>al_fgets</a
	></h1
      ><pre
      ><code
	>char *al_fgets(ALLEGRO_FILE *f, char * const buf, size_t max)
</code
	></pre
      ><p
      >Read a string of bytes terminated with a newline or end-of-file into the buffer given. The line terminator(s), if any, are included in the returned string. A maximum of max-1 bytes are read, with one byte being reserved for a NUL terminator.</p
      ><p
      >Parameters:</p
      ><ul
      ><li
	>f - file to read from</li
	><li
	>buf - buffer to fill</li
	><li
	>max - maximum size of buffer</li
	></ul
      ><p
      >Returns the pointer to buf on success. Returns NULL if an error occurred or if the end of file was reached without reading any bytes.</p
      ><p
      >See <a href="file.html#al_fopen"
	>al_fopen</a
	> about translations of end-of-line characters.</p
      ></div
    ><div id="al_fget_ustr"
    ><h1
      ><a href="#TOC"
	>al_fget_ustr</a
	></h1
      ><pre
      ><code
	>ALLEGRO_USTR *al_fget_ustr(ALLEGRO_FILE *f)
</code
	></pre
      ><p
      >Read a string of bytes terminated with a newline or end-of-file. The line terminator(s), if any, are included in the returned string.</p
      ><p
      >On success returns a pointer to a new ALLEGRO_USTR structure. This must be freed eventually with <a href="utf8.html#al_ustr_free"
	>al_ustr_free</a
	>. Returns NULL if an error occurred or if the end of file was reached without reading any bytes.</p
      ><p
      >See <a href="file.html#al_fopen"
	>al_fopen</a
	> about translations of end-of-line characters.</p
      ></div
    ><div id="al_fputs"
    ><h1
      ><a href="#TOC"
	>al_fputs</a
	></h1
      ><pre
      ><code
	>int al_fputs(ALLEGRO_FILE *f, char const *p)
</code
	></pre
      ><p
      >Writes a string to file. Apart from the return value, this is equivalent to:</p
      ><pre
      ><code
	>al_fwrite(f, p, strlen(p));
</code
	></pre
      ><p
      >Parameters:</p
      ><ul
      ><li
	>f - file handle to write to</li
	><li
	>p - string to write</li
	></ul
      ><p
      >Returns a non-negative integer on success, EOF on error.</p
      ><p
      >Note: depending on the stream type and the mode passed to <a href="file.html#al_fopen"
	>al_fopen</a
	>, newline characters in the string may or may not be automatically translated to native end-of-line sequences, e.g. CR/LF instead of LF.</p
      ></div
    ><div id="standard-io-specific-routines"
    ><h1
      ><a href="#TOC"
	>Standard I/O specific routines</a
	></h1
      ><div id="al_fopen_fd"
      ><h2
	><a href="#TOC"
	  >al_fopen_fd</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_FILE *al_fopen_fd(int fd, const char *mode)
</code
	  ></pre
	><p
	>Create an <a href="file.html#allegro_file"
	  >ALLEGRO_FILE</a
	  > object that operates on an open file descriptor using stdio routines. See the documentation of fdopen() for a description of the 'mode' argument.</p
	><p
	>Returns an ALLEGRO_FILE object on success or NULL on an error. On an error, the Allegro errno will be set and the file descriptor will not be closed.</p
	><p
	>The file descriptor will be closed by <a href="file.html#al_fclose"
	  >al_fclose</a
	  > so you should not call close() on it.</p
	></div
      ><div id="al_make_temp_file"
      ><h2
	><a href="#TOC"
	  >al_make_temp_file</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_FILE *al_make_temp_file(const char *template, ALLEGRO_PATH **ret_path)
</code
	  ></pre
	><p
	>Make a temporary randomly named file given a filename 'template'.</p
	><p
	>'template' is a string giving the format of the generated filename and should include one or more capital Xs. The Xs are replaced with random alphanumeric characters. There should be no path separators.</p
	><p
	>If 'ret_path' is not NULL, the address it points to will be set to point to a new path structure with the name of the temporary file.</p
	><p
	>Returns the opened <a href="file.html#allegro_file"
	  >ALLEGRO_FILE</a
	  > on success, NULL on failure.</p
	></div
      ></div
    ><div id="alternative-file-streams"
    ><h1
      ><a href="#TOC"
	>Alternative file streams</a
	></h1
      ><p
      >By default, the Allegro file I/O routines use the C library I/O routines, hence work with files on the local filesystem, but can be overridden so that you can read and write to other streams. For example, you can work with block of memory or sub-files inside .zip files.</p
      ><p
      >There are two ways to get an <a href="file.html#allegro_file"
	>ALLEGRO_FILE</a
	> that doesn't use stdio. An addon library may provide a function that returns a new ALLEGRO_FILE directly, after which, all al_f* calls on that object will use overridden functions for that type of stream. Alternatively, <a href="file.html#al_set_new_file_interface"
	>al_set_new_file_interface</a
	> changes which function will handle the following <a href="file.html#al_fopen"
	>al_fopen</a
	> calls for the current thread.</p
      ><div id="al_set_new_file_interface"
      ><h2
	><a href="#TOC"
	  >al_set_new_file_interface</a
	  ></h2
	><pre
	><code
	  >void al_set_new_file_interface(const ALLEGRO_FILE_INTERFACE *file_interface)
</code
	  ></pre
	><p
	>Set the <a href="file.html#allegro_file_interface"
	  >ALLEGRO_FILE_INTERFACE</a
	  > table for the calling thread. This will change the handler for later calls to <a href="file.html#al_fopen"
	  >al_fopen</a
	  >.</p
	><p
	>See also: <a href="file.html#al_set_standard_file_interface"
	  >al_set_standard_file_interface</a
	  >, <a href="state.html#al_store_state"
	  >al_store_state</a
	  >, <a href="state.html#al_restore_state"
	  >al_restore_state</a
	  >.</p
	></div
      ><div id="al_set_standard_file_interface"
      ><h2
	><a href="#TOC"
	  >al_set_standard_file_interface</a
	  ></h2
	><pre
	><code
	  >void al_set_standard_file_interface(void)
</code
	  ></pre
	><p
	>Set the <a href="file.html#allegro_file_interface"
	  >ALLEGRO_FILE_INTERFACE</a
	  > table to the default, for the calling thread. This will change the handler for later calls to <a href="file.html#al_fopen"
	  >al_fopen</a
	  >.</p
	><p
	>See also: <a href="file.html#al_set_new_file_interface"
	  >al_set_new_file_interface</a
	  ></p
	></div
      ><div id="al_get_new_file_interface"
      ><h2
	><a href="#TOC"
	  >al_get_new_file_interface</a
	  ></h2
	><pre
	><code
	  >const ALLEGRO_FILE_INTERFACE *al_get_new_file_interface(void)
</code
	  ></pre
	><p
	>Return a pointer to the <a href="file.html#allegro_file_interface"
	  >ALLEGRO_FILE_INTERFACE</a
	  > table in effect for the calling thread.</p
	><p
	>See also: <a href="state.html#al_store_state"
	  >al_store_state</a
	  >, <a href="state.html#al_restore_state"
	  >al_restore_state</a
	  >.</p
	></div
      ></div
    ></td>
</tr>
</table>


<p>
Last updated: 2010-04-01 08:44:50 UTC
</p>
</body
  ></html
>

