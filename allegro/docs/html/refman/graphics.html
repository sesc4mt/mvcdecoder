<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Graphics</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><a href="index.html"
    ><strong
      >Contents</strong
      ></a
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem</a
    ></li
  ><li
  ><a href="fixed.html"
    >Fixed</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="platform.html"
    >Platform-specific</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="transformations.html"
    >Transformations</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><a href="index.html#addons"
    ><strong
      >Addons</strong
      ></a
    ></li
  ><li
  ><a href="audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="image.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function on_search(index, control) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == control.keywords[index]) {
            break;
        }
    }
    location.href = search_urls[i];
}
</script>Search<br /> <input type="text" name="q" id="q" size="15" autocomplete="off" /><br /><script type="text/javascript"> new autosuggest("q", search_index, null, on_search); </script>
</div>

</td>
<td class="content">


<h1 class="title"
    >Graphics</h1
    ><div id="TOC"
    ><ul
      ><li
	><a href="#colors"
	  >Colors</a
	  ><ul
	  ><li
	    ><a href="#allegro_color"
	      >ALLEGRO_COLOR</a
	      ></li
	    ><li
	    ><a href="#al_map_rgb"
	      >al_map_rgb</a
	      ></li
	    ><li
	    ><a href="#al_map_rgb_f"
	      >al_map_rgb_f</a
	      ></li
	    ><li
	    ><a href="#al_map_rgba"
	      >al_map_rgba</a
	      ></li
	    ><li
	    ><a href="#al_map_rgba_f"
	      >al_map_rgba_f</a
	      ></li
	    ><li
	    ><a href="#al_unmap_rgb"
	      >al_unmap_rgb</a
	      ></li
	    ><li
	    ><a href="#al_unmap_rgb_f"
	      >al_unmap_rgb_f</a
	      ></li
	    ><li
	    ><a href="#al_unmap_rgba"
	      >al_unmap_rgba</a
	      ></li
	    ><li
	    ><a href="#al_unmap_rgba_f"
	      >al_unmap_rgba_f</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#locking-and-pixel-formats"
	  >Locking and pixel formats</a
	  ><ul
	  ><li
	    ><a href="#allegro_locked_region"
	      >ALLEGRO_LOCKED_REGION</a
	      ></li
	    ><li
	    ><a href="#allegro_pixel_format"
	      >ALLEGRO_PIXEL_FORMAT</a
	      ></li
	    ><li
	    ><a href="#al_get_pixel_size"
	      >al_get_pixel_size</a
	      ></li
	    ><li
	    ><a href="#al_get_pixel_format_bits"
	      >al_get_pixel_format_bits</a
	      ></li
	    ><li
	    ><a href="#al_lock_bitmap"
	      >al_lock_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_lock_bitmap_region"
	      >al_lock_bitmap_region</a
	      ></li
	    ><li
	    ><a href="#al_unlock_bitmap"
	      >al_unlock_bitmap</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#bitmap-creation"
	  >Bitmap creation</a
	  ><ul
	  ><li
	    ><a href="#allegro_bitmap"
	      >ALLEGRO_BITMAP</a
	      ></li
	    ><li
	    ><a href="#al_clone_bitmap"
	      >al_clone_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_create_bitmap"
	      >al_create_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_create_sub_bitmap"
	      >al_create_sub_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_destroy_bitmap"
	      >al_destroy_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_get_new_bitmap_flags"
	      >al_get_new_bitmap_flags</a
	      ></li
	    ><li
	    ><a href="#al_get_new_bitmap_format"
	      >al_get_new_bitmap_format</a
	      ></li
	    ><li
	    ><a href="#al_set_new_bitmap_flags"
	      >al_set_new_bitmap_flags</a
	      ></li
	    ><li
	    ><a href="#al_set_new_bitmap_format"
	      >al_set_new_bitmap_format</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#bitmap-properties"
	  >Bitmap properties</a
	  ><ul
	  ><li
	    ><a href="#al_get_bitmap_flags"
	      >al_get_bitmap_flags</a
	      ></li
	    ><li
	    ><a href="#al_get_bitmap_format"
	      >al_get_bitmap_format</a
	      ></li
	    ><li
	    ><a href="#al_get_bitmap_height"
	      >al_get_bitmap_height</a
	      ></li
	    ><li
	    ><a href="#al_get_bitmap_width"
	      >al_get_bitmap_width</a
	      ></li
	    ><li
	    ><a href="#al_get_pixel"
	      >al_get_pixel</a
	      ></li
	    ><li
	    ><a href="#al_is_bitmap_locked"
	      >al_is_bitmap_locked</a
	      ></li
	    ><li
	    ><a href="#al_is_compatible_bitmap"
	      >al_is_compatible_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_is_sub_bitmap"
	      >al_is_sub_bitmap</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#drawing-operations"
	  >Drawing operations</a
	  ><ul
	  ><li
	    ><a href="#al_clear_to_color"
	      >al_clear_to_color</a
	      ></li
	    ><li
	    ><a href="#al_draw_bitmap"
	      >al_draw_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_draw_bitmap_region"
	      >al_draw_bitmap_region</a
	      ></li
	    ><li
	    ><a href="#al_draw_pixel"
	      >al_draw_pixel</a
	      ></li
	    ><li
	    ><a href="#al_draw_rotated_bitmap"
	      >al_draw_rotated_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_draw_rotated_scaled_bitmap"
	      >al_draw_rotated_scaled_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_draw_scaled_bitmap"
	      >al_draw_scaled_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_get_target_bitmap"
	      >al_get_target_bitmap</a
	      ></li
	    ><li
	    ><a href="#al_put_pixel"
	      >al_put_pixel</a
	      ></li
	    ><li
	    ><a href="#al_put_blended_pixel"
	      >al_put_blended_pixel</a
	      ></li
	    ><li
	    ><a href="#al_set_target_bitmap"
	      >al_set_target_bitmap</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#blending-modes"
	  >Blending modes</a
	  ><ul
	  ><li
	    ><a href="#al_get_blender"
	      >al_get_blender</a
	      ></li
	    ><li
	    ><a href="#al_get_separate_blender"
	      >al_get_separate_blender</a
	      ></li
	    ><li
	    ><a href="#al_set_blender"
	      >al_set_blender</a
	      ></li
	    ><li
	    ><a href="#al_set_separate_blender"
	      >al_set_separate_blender</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#clipping"
	  >Clipping</a
	  ><ul
	  ><li
	    ><a href="#al_get_clipping_rectangle"
	      >al_get_clipping_rectangle</a
	      ></li
	    ><li
	    ><a href="#al_set_clipping_rectangle"
	      >al_set_clipping_rectangle</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#graphics-utility-functions"
	  >Graphics utility functions</a
	  ><ul
	  ><li
	    ><a href="#al_convert_mask_to_alpha"
	      >al_convert_mask_to_alpha</a
	      ></li
	    ></ul
	  ></li
	><li
	><a href="#deferred-drawing"
	  >Deferred drawing</a
	  ><ul
	  ><li
	    ><a href="#al_hold_bitmap_drawing"
	      >al_hold_bitmap_drawing</a
	      ></li
	    ><li
	    ><a href="#al_is_bitmap_drawing_held"
	      >al_is_bitmap_drawing_held</a
	      ></li
	    ></ul
	  ></li
	></ul
      ></div
    ><p
    >These functions are declared in the main Allegro header file:</p
    ><pre
    ><code
      >#include &lt;allegro5/allegro.h&gt;
</code
      ></pre
    ><div id="colors"
    ><h1
      ><a href="#TOC"
	>Colors</a
	></h1
      ><div id="allegro_color"
      ><h2
	><a href="#TOC"
	  >ALLEGRO_COLOR</a
	  ></h2
	><pre
	><code
	  >typedef struct ALLEGRO_COLOR ALLEGRO_COLOR;
</code
	  ></pre
	><p
	>An ALLEGRO_COLOR structure describes a color in a device independant way. Use <a href="graphics.html#al_map_rgb"
	  >al_map_rgb</a
	  > et al. and <a href="graphics.html#al_unmap_rgb"
	  >al_unmap_rgb</a
	  > et al. to translate from and to various color representations.</p
	></div
      ><div id="al_map_rgb"
      ><h2
	><a href="#TOC"
	  >al_map_rgb</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_COLOR al_map_rgb(
   unsigned char r, unsigned char g, unsigned char b)
</code
	  ></pre
	><p
	>Convert r, g, b (ranging from 0-255) into an ALLEGRO_COLOR, using 255 for alpha.</p
	><p
	>See also: <a href="graphics.html#al_map_rgba"
	  >al_map_rgba</a
	  >, <a href="graphics.html#al_map_rgba_f"
	  >al_map_rgba_f</a
	  >, <a href="graphics.html#al_map_rgb_f"
	  >al_map_rgb_f</a
	  ></p
	></div
      ><div id="al_map_rgb_f"
      ><h2
	><a href="#TOC"
	  >al_map_rgb_f</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_COLOR al_map_rgb_f(float r, float g, float b)
</code
	  ></pre
	><p
	>Convert r, g, b, (ranging from 0.0f-1.0f) into an ALLEGRO_COLOR, using 1.0f for alpha.</p
	><p
	>See also: <a href="graphics.html#al_map_rgba"
	  >al_map_rgba</a
	  >, <a href="graphics.html#al_map_rgb"
	  >al_map_rgb</a
	  >, <a href="graphics.html#al_map_rgba_f"
	  >al_map_rgba_f</a
	  ></p
	></div
      ><div id="al_map_rgba"
      ><h2
	><a href="#TOC"
	  >al_map_rgba</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_COLOR al_map_rgba(
   unsigned char r, unsigned char g, unsigned char b, unsigned char a)
</code
	  ></pre
	><p
	>Convert r, g, b, a (ranging from 0-255) into an ALLEGRO_COLOR.</p
	><p
	>See also: <a href="graphics.html#al_map_rgb"
	  >al_map_rgb</a
	  >, <a href="graphics.html#al_map_rgba_f"
	  >al_map_rgba_f</a
	  >, <a href="graphics.html#al_map_rgb_f"
	  >al_map_rgb_f</a
	  ></p
	></div
      ><div id="al_map_rgba_f"
      ><h2
	><a href="#TOC"
	  >al_map_rgba_f</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_COLOR al_map_rgba_f(float r, float g, float b, float a)
</code
	  ></pre
	><p
	>Convert r, g, b, a (ranging from 0.0f-1.0f) into an ALLEGRO_COLOR.</p
	><p
	>See also: <a href="graphics.html#al_map_rgba"
	  >al_map_rgba</a
	  >, <a href="graphics.html#al_map_rgb"
	  >al_map_rgb</a
	  >, <a href="graphics.html#al_map_rgb_f"
	  >al_map_rgb_f</a
	  ></p
	></div
      ><div id="al_unmap_rgb"
      ><h2
	><a href="#TOC"
	  >al_unmap_rgb</a
	  ></h2
	><pre
	><code
	  >void al_unmap_rgb(ALLEGRO_COLOR color,
   unsigned char *r, unsigned char *g, unsigned char *b)
</code
	  ></pre
	><p
	>Retrieves components of an ALLEGRO_COLOR, ignoring alpha Components will range from 0-255.</p
	><p
	>See also: <a href="graphics.html#al_unmap_rgba"
	  >al_unmap_rgba</a
	  >, <a href="graphics.html#al_unmap_rgba_f"
	  >al_unmap_rgba_f</a
	  >, <a href="graphics.html#al_unmap_rgb_f"
	  >al_unmap_rgb_f</a
	  ></p
	></div
      ><div id="al_unmap_rgb_f"
      ><h2
	><a href="#TOC"
	  >al_unmap_rgb_f</a
	  ></h2
	><pre
	><code
	  >void al_unmap_rgb_f(ALLEGRO_COLOR color, float *r, float *g, float *b)
</code
	  ></pre
	><p
	>Retrieves components of an ALLEGRO_COLOR, ignoring alpha. Components will range from 0.0f-1.0f.</p
	><p
	>See also: <a href="graphics.html#al_unmap_rgba"
	  >al_unmap_rgba</a
	  >, <a href="graphics.html#al_unmap_rgb"
	  >al_unmap_rgb</a
	  >, <a href="graphics.html#al_unmap_rgba_f"
	  >al_unmap_rgba_f</a
	  ></p
	></div
      ><div id="al_unmap_rgba"
      ><h2
	><a href="#TOC"
	  >al_unmap_rgba</a
	  ></h2
	><pre
	><code
	  >void al_unmap_rgba(ALLEGRO_COLOR color,
   unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a)
</code
	  ></pre
	><p
	>Retrieves components of an ALLEGRO_COLOR. Components will range from 0-255.</p
	><p
	>See also: <a href="graphics.html#al_unmap_rgb"
	  >al_unmap_rgb</a
	  >, <a href="graphics.html#al_unmap_rgba_f"
	  >al_unmap_rgba_f</a
	  >, <a href="graphics.html#al_unmap_rgb_f"
	  >al_unmap_rgb_f</a
	  ></p
	></div
      ><div id="al_unmap_rgba_f"
      ><h2
	><a href="#TOC"
	  >al_unmap_rgba_f</a
	  ></h2
	><pre
	><code
	  >void al_unmap_rgba_f(ALLEGRO_COLOR color,
   float *r, float *g, float *b, float *a)
</code
	  ></pre
	><p
	>Retrieves components of an ALLEGRO_COLOR. Components will range from 0.0f-1.0f.</p
	><p
	>See also: <a href="graphics.html#al_unmap_rgba"
	  >al_unmap_rgba</a
	  >, <a href="graphics.html#al_unmap_rgb"
	  >al_unmap_rgb</a
	  >, <a href="graphics.html#al_unmap_rgb_f"
	  >al_unmap_rgb_f</a
	  ></p
	></div
      ></div
    ><div id="locking-and-pixel-formats"
    ><h1
      ><a href="#TOC"
	>Locking and pixel formats</a
	></h1
      ><div id="allegro_locked_region"
      ><h2
	><a href="#TOC"
	  >ALLEGRO_LOCKED_REGION</a
	  ></h2
	><pre
	><code
	  >typedef struct ALLEGRO_LOCKED_REGION ALLEGRO_LOCKED_REGION;
</code
	  ></pre
	><p
	>Users who wish to manually edit or read from a bitmap are required to lock it first. The ALLEGRO_LOCKED_REGION structure represents the locked region of the bitmap. This call will work with any bitmap, including memory bitmaps.</p
	><pre
	><code
	  >typedef struct ALLEGRO_LOCKED_REGION {
        void *data; // the bitmap data
        int format; // the pixel format of the data
        int pitch;  // the size in bytes of a single line
                    // pitch may be greater than pixel_size*bitmap-&gt;w
                    // i.e. padded with extra bytes
}
</code
	  ></pre
	><p
	>See also: <a href="graphics.html#al_lock_bitmap"
	  >al_lock_bitmap</a
	  >, <a href="graphics.html#al_lock_bitmap_region"
	  >al_lock_bitmap_region</a
	  >, <a href="graphics.html#al_unlock_bitmap"
	  >al_unlock_bitmap</a
	  >, <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  ></p
	></div
      ><div id="allegro_pixel_format"
      ><h2
	><a href="#TOC"
	  >ALLEGRO_PIXEL_FORMAT</a
	  ></h2
	><pre
	><code
	  >typedef enum ALLEGRO_PIXEL_FORMAT
</code
	  ></pre
	><p
	>Pixel formats. Each pixel format specifies the exact size and bit layout of a pixel in memory. Components are specified from high bits to low bits, so for example a fully opaque red pixel in ARGB_8888 format is 0xFFFF0000.</p
	><p
	>Note:</p
	><p
	>The pixel format is independent of endianness. That is, in the above example you can always get the red component with</p
	><p
	>(pixel &amp; 0x00ff0000) &gt;&gt; 16</p
	><p
	>But you can <em
	  >not</em
	  > rely on this code:</p
	><p
	>*(pixel + 2)</p
	><p
	>It will return the red component on little endian systems, but the green component on big endian systems.</p
	><p
	>Also note that Allegro's naming is different from OpenGL naming here, where a format of GL_RGBA8 merely defines the component order and the exact layout including endianness treatment is specified separately. Usually GL_RGBA8 will correspond to ALLEGRO_PIXEL_ABGR_8888 though on little endian systems, so care must be taken (note the reversal of RGBA &lt;-&gt; ABGR).</p
	><p
	>The only exception to this ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE which will always have the components as 4 bytes corresponding to red, green, blue and alpha, in this order, independent of the endianness.</p
	><table
	><tr class="header"
	  ><th align="left" style="width: 48%;"
	    >Format</th
	    ><th align="left" style="width: 51%;"
	    >Notes</th
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY</td
	    ><td align="left"
	    >Let the driver choose a format. This is the default format at program start.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_NO_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a format without alpha.</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_WITH_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a format with alpha.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_15_NO_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 15 bit format without alpha.</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_15_WITH_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 15 bit format with alpha.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 16 bit format without alpha.</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 16 bit format with alpha.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 24 bit format without alpha.</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_24_WITH_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 24 bit format with alpha.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_32_NO_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 32 bit format without alpha.</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA</td
	    ><td align="left"
	    >Let the driver choose a 32 bit format with alpha.</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ARGB_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGBA_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ARGB_4444</td
	    ><td align="left"
	    >16 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGB_888</td
	    ><td align="left"
	    >24 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGB_565</td
	    ><td align="left"
	    >16 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGB_555</td
	    ><td align="left"
	    >15 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGBA_5551</td
	    ><td align="left"
	    >16 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ARGB_1555</td
	    ><td align="left"
	    >16 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ABGR_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_XBGR_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_BGR_888</td
	    ><td align="left"
	    >24 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_BGR_565</td
	    ><td align="left"
	    >16 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_BGR_555</td
	    ><td align="left"
	    >15 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_RGBX_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_XRGB_8888</td
	    ><td align="left"
	    >32 bit</td
	    ></tr
	  ><tr class="odd"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ABGR_F32</td
	    ><td align="left"
	    >128 bit</td
	    ></tr
	  ><tr class="even"
	  ><td align="left"
	    >ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE</td
	    ><td align="left"
	    >Like the version without _LE, but the component order is guaranteed to be red, green, blue, alpha. This only makes a difference on big endian systems, on little endian it is just an alias.</td
	    ></tr
	  ></table
	><p
	>See also: <a href="graphics.html#al_set_new_bitmap_format"
	  >al_set_new_bitmap_format</a
	  >, <a href="graphics.html#al_get_bitmap_format"
	  >al_get_bitmap_format</a
	  ></p
	></div
      ><div id="al_get_pixel_size"
      ><h2
	><a href="#TOC"
	  >al_get_pixel_size</a
	  ></h2
	><pre
	><code
	  >int al_get_pixel_size(int format)
</code
	  ></pre
	><p
	>Return the number of bytes that a pixel of the given format occupies.</p
	><p
	>See also: <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_get_pixel_format_bits"
	  >al_get_pixel_format_bits</a
	  ></p
	></div
      ><div id="al_get_pixel_format_bits"
      ><h2
	><a href="#TOC"
	  >al_get_pixel_format_bits</a
	  ></h2
	><pre
	><code
	  >int al_get_pixel_format_bits(int format)
</code
	  ></pre
	><p
	>Return the number of bits that a pixel of the given format occupies.</p
	><p
	>See also: <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_get_pixel_size"
	  >al_get_pixel_size</a
	  ></p
	></div
      ><div id="al_lock_bitmap"
      ><h2
	><a href="#TOC"
	  >al_lock_bitmap</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_LOCKED_REGION *al_lock_bitmap(ALLEGRO_BITMAP *bitmap,
   int format, int flags)
</code
	  ></pre
	><p
	>Lock an entire bitmap for reading or writing. If the bitmap is a display bitmap it will be updated from system memory after the bitmap is unlocked (unless locked read only). Returns NULL if the bitmap cannot be locked, e.g. the bitmap was locked previously and not unlocked.</p
	><p
	>Flags are:</p
	><ul
	><li
	  ><p
	    >ALLEGRO_LOCK_READONLY - The locked region will not be written to. This can be faster if the bitmap is a video texture, as it can be discarded after the lock instead of uploaded back to the card.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_LOCK_WRITEONLY - The locked region will not be read from. This can be faster if the bitmap is a video texture, as no data need to be read from the video card. You are required to fill in all pixels before unlocking the bitmap again, so be careful when using this flag.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_LOCK_READWRITE - The locked region can be written to and read from.</p
	    ></li
	  ></ul
	><p
	>'format' indicates the pixel format that the returned buffer will be in. To lock in the same format as the bitmap stores it's data internally, call with <code
	  >al_get_bitmap_format(bitmap)</code
	  > as the format or use ALLEGRO_PIXEL_FORMAT_ANY. Locking in the native format will usually be faster.</p
	><p
	>Note:</p
	><p
	>While a bitmap is locked, you can not use any drawing operations on it (with the sole exception of <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  > and <a href="graphics.html#al_put_blended_pixel"
	  >al_put_blended_pixel</a
	  >).</p
	><p
	>See also: <a href="graphics.html#allegro_locked_region"
	  >ALLEGRO_LOCKED_REGION</a
	  >, <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_unlock_bitmap"
	  >al_unlock_bitmap</a
	  ></p
	></div
      ><div id="al_lock_bitmap_region"
      ><h2
	><a href="#TOC"
	  >al_lock_bitmap_region</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_LOCKED_REGION *al_lock_bitmap_region(ALLEGRO_BITMAP *bitmap,
   int x, int y, int width, int height, int format, int flags)
</code
	  ></pre
	><p
	>Like <a href="graphics.html#al_lock_bitmap"
	  >al_lock_bitmap</a
	  >, but only locks a specific area of the bitmap. If the bitmap is a display bitmap, only that area of the texture will be updated when it is unlocked. Locking only the region you indend to modify will be faster than locking the whole bitmap.</p
	><p
	>See also: <a href="graphics.html#allegro_locked_region"
	  >ALLEGRO_LOCKED_REGION</a
	  >, <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_unlock_bitmap"
	  >al_unlock_bitmap</a
	  ></p
	></div
      ><div id="al_unlock_bitmap"
      ><h2
	><a href="#TOC"
	  >al_unlock_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_unlock_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Unlock a previously locked bitmap or bitmap region. If the bitmap is a display bitmap, the texture will be updated to match the system memory copy (unless it was locked read only).</p
	><p
	>See also: <a href="graphics.html#al_lock_bitmap"
	  >al_lock_bitmap</a
	  >, <a href="graphics.html#al_lock_bitmap_region"
	  >al_lock_bitmap_region</a
	  ></p
	></div
      ></div
    ><div id="bitmap-creation"
    ><h1
      ><a href="#TOC"
	>Bitmap creation</a
	></h1
      ><div id="allegro_bitmap"
      ><h2
	><a href="#TOC"
	  >ALLEGRO_BITMAP</a
	  ></h2
	><pre
	><code
	  >typedef struct ALLEGRO_BITMAP ALLEGRO_BITMAP;
</code
	  ></pre
	><p
	>Abstract type representing a bitmap (2D image).</p
	></div
      ><div id="al_clone_bitmap"
      ><h2
	><a href="#TOC"
	  >al_clone_bitmap</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_BITMAP *al_clone_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Clone a bitmap &quot;exactly&quot;, formats can be different.</p
	><p
	>XXX document this better</p
	><p
	>See also: <a href="graphics.html#al_create_bitmap"
	  >al_create_bitmap</a
	  ></p
	></div
      ><div id="al_create_bitmap"
      ><h2
	><a href="#TOC"
	  >al_create_bitmap</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_BITMAP *al_create_bitmap(int w, int h)
</code
	  ></pre
	><p
	>Creates a new bitmap using the bitmap format and flags for the current thread. Blitting between bitmaps of differing formats, or blitting between memory bitmaps and display bitmaps may be slow.</p
	><p
	>Unless you set the ALLEGRO_MEMORY_BITMAP flag, the bitmap is created for the current display. Blitting to another display may be slow.</p
	><p
	>If a display bitmap is created, there may be limitations on the allowed dimensions. For example a DirectX or OpenGL backend usually has a maximum allowed texture size - so if bitmap creation fails for very large dimensions, you may want to re-try with a smaller bitmap.</p
	><p
	>See also: <a href="graphics.html#al_set_new_bitmap_format"
	  >al_set_new_bitmap_format</a
	  >, <a href="graphics.html#al_set_new_bitmap_flags"
	  >al_set_new_bitmap_flags</a
	  >, <a href="graphics.html#al_clone_bitmap"
	  >al_clone_bitmap</a
	  >, <a href="graphics.html#al_create_sub_bitmap"
	  >al_create_sub_bitmap</a
	  ></p
	></div
      ><div id="al_create_sub_bitmap"
      ><h2
	><a href="#TOC"
	  >al_create_sub_bitmap</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_BITMAP *al_create_sub_bitmap(ALLEGRO_BITMAP *parent,
   int x, int y, int w, int h)
</code
	  ></pre
	><p
	>Creates a sub-bitmap of the parent, at the specified coordinates and of the specified size. A sub-bitmap is a bitmap that shares drawing memory with a pre-existing (parent) bitmap, but possibly with a different size and clipping settings.</p
	><p
	>If the sub-bitmap does not lie completely inside the parent bitmap, then it is automatically clipped so that it does.</p
	><p
	>See the discussion in <a href="display.html#al_get_backbuffer"
	  >al_get_backbuffer</a
	  > about using sub-bitmaps of the backbuffer.</p
	><p
	>The parent bitmap's clipping rectangles are ignored.</p
	><p
	>If a sub-bitmap was not or cannot be created then NULL is returned.</p
	><p
	>Note that destroying parents of sub-bitmaps will not destroy the sub-bitmaps; instead the sub-bitmaps become invalid and should no longer be used.</p
	><p
	>See also: <a href="graphics.html#al_create_bitmap"
	  >al_create_bitmap</a
	  ></p
	></div
      ><div id="al_destroy_bitmap"
      ><h2
	><a href="#TOC"
	  >al_destroy_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_destroy_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Destroys the given bitmap, freeing all resources used by it. Does nothing if given the null pointer.</p
	></div
      ><div id="al_get_new_bitmap_flags"
      ><h2
	><a href="#TOC"
	  >al_get_new_bitmap_flags</a
	  ></h2
	><pre
	><code
	  >int al_get_new_bitmap_flags(void)
</code
	  ></pre
	><p
	>Returns the flags used for newly created bitmaps.</p
	><p
	>See also: <a href="graphics.html#al_set_new_bitmap_flags"
	  >al_set_new_bitmap_flags</a
	  ></p
	></div
      ><div id="al_get_new_bitmap_format"
      ><h2
	><a href="#TOC"
	  >al_get_new_bitmap_format</a
	  ></h2
	><pre
	><code
	  >int al_get_new_bitmap_format(void)
</code
	  ></pre
	><p
	>Returns the format used for newly created bitmaps.</p
	><p
	>See also: <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_set_new_bitmap_format"
	  >al_set_new_bitmap_format</a
	  ></p
	></div
      ><div id="al_set_new_bitmap_flags"
      ><h2
	><a href="#TOC"
	  >al_set_new_bitmap_flags</a
	  ></h2
	><pre
	><code
	  >void al_set_new_bitmap_flags(int flags)
</code
	  ></pre
	><p
	>Sets the flags to use for newly created bitmaps. Valid flags are:</p
	><ul
	><li
	  ><p
	    >ALLEGRO_VIDEO_BITMAP - This is the default flag. Creates a bitmap that resides in the video card memory. These types of bitmaps receive the greatest benefit from hardware acceleration.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_MEMORY_BITMAP - Create a bitmap residing in system memory. Operations on, and with, memory bitmaps will not be hardware accelerated. However, direct pixel access can be relatively quick compared to video bitmaps, which depend on the display driver in use. <em
	      >Note: Allegro's software rendering routines are currently very unoptimised.</em
	      ></p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_KEEP_BITMAP_FORMAT - Only used when loading bitmaps from disk files, forces the resulting ALLEGRO_BITMAP to use the same format as the file.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_FORCE_LOCKING - When drawing to a bitmap with this flag set, always use pixel locking and draw to it using Allegro's software drawing primitives. This should never be used if you plan to draw to the bitmap using Allegro's graphics primitives as it would cause severe performance penalties. However if you know that the bitmap will only ever be accessed by locking it, no unneeded FBOs will be created for it in the OpenGL drivers.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_NO_PRESERVE_TEXTURE - Normally, every effort is taken to preserve the contents of bitmaps since some drivers may forget them. This can take extra time. If you know it doesn't matter if a bitmap keeps its image, for example a temporary buffer, use this flag to tell Allegro not to attempt to preserve the contents of bitmaps created after this flag is set. This can lead to speed improvements in your program.</p
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_ALPHA_TEST - This is a driver hint only. It tells the graphics driver to do alpha testing instead of alpha blending on bitmaps created with this flag. Alpha testing is usually faster and preferred if your bitmaps have only one level of alpha (0). This flag is currently not widely implemented (i.e., only for memory bitmaps).</p
	    ></li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_get_new_bitmap_flags"
	  >al_get_new_bitmap_flags</a
	  >, <a href="graphics.html#al_get_bitmap_flags"
	  >al_get_bitmap_flags</a
	  ></p
	></div
      ><div id="al_set_new_bitmap_format"
      ><h2
	><a href="#TOC"
	  >al_set_new_bitmap_format</a
	  ></h2
	><pre
	><code
	  >void al_set_new_bitmap_format(int format)
</code
	  ></pre
	><p
	>Sets the pixel format for newly created bitmaps. The default format is 0 and means the display driver will choose the best format.</p
	><p
	>See also: <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_get_new_bitmap_format"
	  >al_get_new_bitmap_format</a
	  >, <a href="graphics.html#al_get_bitmap_format"
	  >al_get_bitmap_format</a
	  ></p
	></div
      ></div
    ><div id="bitmap-properties"
    ><h1
      ><a href="#TOC"
	>Bitmap properties</a
	></h1
      ><div id="al_get_bitmap_flags"
      ><h2
	><a href="#TOC"
	  >al_get_bitmap_flags</a
	  ></h2
	><pre
	><code
	  >int al_get_bitmap_flags(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Return the flags user to create the bitmap.</p
	><p
	>See also: <a href="graphics.html#al_set_new_bitmap_flags"
	  >al_set_new_bitmap_flags</a
	  ></p
	></div
      ><div id="al_get_bitmap_format"
      ><h2
	><a href="#TOC"
	  >al_get_bitmap_format</a
	  ></h2
	><pre
	><code
	  >int al_get_bitmap_format(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Returns the pixel format of a bitmap.</p
	><p
	>See also: <a href="graphics.html#allegro_pixel_format"
	  >ALLEGRO_PIXEL_FORMAT</a
	  >, <a href="graphics.html#al_set_new_bitmap_flags"
	  >al_set_new_bitmap_flags</a
	  ></p
	></div
      ><div id="al_get_bitmap_height"
      ><h2
	><a href="#TOC"
	  >al_get_bitmap_height</a
	  ></h2
	><pre
	><code
	  >int al_get_bitmap_height(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Returns the height of a bitmap in pixels.</p
	></div
      ><div id="al_get_bitmap_width"
      ><h2
	><a href="#TOC"
	  >al_get_bitmap_width</a
	  ></h2
	><pre
	><code
	  >int al_get_bitmap_width(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Returns the width of a bitmap in pixels.</p
	></div
      ><div id="al_get_pixel"
      ><h2
	><a href="#TOC"
	  >al_get_pixel</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_COLOR al_get_pixel(ALLEGRO_BITMAP *bitmap, int x, int y)
</code
	  ></pre
	><p
	>Get a pixel's color value from the specified bitmap. This operation is slow on non-memory bitmaps. Consider locking the bitmap if you are going to use this function multiple times on the same bitmap.</p
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  >, <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  ></p
	></div
      ><div id="al_is_bitmap_locked"
      ><h2
	><a href="#TOC"
	  >al_is_bitmap_locked</a
	  ></h2
	><pre
	><code
	  >bool al_is_bitmap_locked(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Returns whether or not a bitmap is already locked.</p
	><p
	>See also: <a href="graphics.html#al_lock_bitmap"
	  >al_lock_bitmap</a
	  >, <a href="graphics.html#al_lock_bitmap_region"
	  >al_lock_bitmap_region</a
	  >, <a href="graphics.html#al_unlock_bitmap"
	  >al_unlock_bitmap</a
	  ></p
	></div
      ><div id="al_is_compatible_bitmap"
      ><h2
	><a href="#TOC"
	  >al_is_compatible_bitmap</a
	  ></h2
	><pre
	><code
	  >bool al_is_compatible_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>D3D and OpenGL allow sharing a texture in a way so it can be used for multiple windows. Each ALLEGRO_BITMAP created with <a href="graphics.html#al_create_bitmap"
	  >al_create_bitmap</a
	  > however is usually tied to a single ALLEGRO_DISPLAY. This function can be used to know if the bitmap is compatible with the current display, even if it is another display than the one it was created with. It returns true if the bitmap is compatible (things like a cached texture version can be used) and false otherwise (blitting in the current display will be slow).</p
	><p
	>The only time this function is useful is if you are using multiple windows and need accelerated blitting of the same bitmaps to both.</p
	><p
	>Returns true if the bitmap is compatible with the current display, false otherwise. If there is no current display, false is returned.</p
	></div
      ><div id="al_is_sub_bitmap"
      ><h2
	><a href="#TOC"
	  >al_is_sub_bitmap</a
	  ></h2
	><pre
	><code
	  >bool al_is_sub_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Returns true if the specified bitmap is a sub-bitmap, false otherwise.</p
	><p
	>See also: <a href="graphics.html#al_create_sub_bitmap"
	  >al_create_sub_bitmap</a
	  ></p
	></div
      ></div
    ><div id="drawing-operations"
    ><h1
      ><a href="#TOC"
	>Drawing operations</a
	></h1
      ><p
      >All drawing operations draw to the current &quot;target bitmap&quot; of the current thread. Initially, the target bitmap will be the backbuffer of the last display created in a thread.</p
      ><div id="al_clear_to_color"
      ><h2
	><a href="#TOC"
	  >al_clear_to_color</a
	  ></h2
	><pre
	><code
	  >void al_clear_to_color(ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Clear the complete target bitmap, but confined by the clipping rectangle.</p
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  >, <a href="graphics.html#al_set_clipping_rectangle"
	  >al_set_clipping_rectangle</a
	  ></p
	></div
      ><div id="al_draw_bitmap"
      ><h2
	><a href="#TOC"
	  >al_draw_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_draw_bitmap(ALLEGRO_BITMAP *bitmap, float dx, float dy, int flags)
</code
	  ></pre
	><p
	>Draws an unscaled, unrotated bitmap at the given position to the current target bitmap (see <a href="graphics.html#al_set_target_bitmap"
	  >al_set_target_bitmap</a
	  >). flags can be a combination of:</p
	><ul
	><li
	  >ALLEGRO_FLIP_HORIZONTAL - flip the bitmap about the y-axis</li
	  ><li
	  >ALLEGRO_FLIP_VERTICAL - flip the bitmap about the x-axis</li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_draw_bitmap_region"
	  >al_draw_bitmap_region</a
	  >, <a href="graphics.html#al_draw_scaled_bitmap"
	  >al_draw_scaled_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_bitmap"
	  >al_draw_rotated_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_scaled_bitmap"
	  >al_draw_rotated_scaled_bitmap</a
	  ></p
	></div
      ><div id="al_draw_bitmap_region"
      ><h2
	><a href="#TOC"
	  >al_draw_bitmap_region</a
	  ></h2
	><pre
	><code
	  >void al_draw_bitmap_region(ALLEGRO_BITMAP *bitmap,
   float sx, float sy, float sw, float sh, float dx, float dy, int flags)
</code
	  ></pre
	><p
	>Draws a region of the given bitmap to the target bitmap.</p
	><ul
	><li
	  >sx - source x</li
	  ><li
	  >sy - source y</li
	  ><li
	  >sw - source width (width of region to blit)</li
	  ><li
	  >sh - source height (height of region to blit)</li
	  ><li
	  >dx - destination x</li
	  ><li
	  >dy - destination y</li
	  ><li
	  >flags - same as for <a href="graphics.html#al_draw_bitmap"
	    >al_draw_bitmap</a
	    ></li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_draw_bitmap"
	  >al_draw_bitmap</a
	  >, <a href="graphics.html#al_draw_scaled_bitmap"
	  >al_draw_scaled_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_bitmap"
	  >al_draw_rotated_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_scaled_bitmap"
	  >al_draw_rotated_scaled_bitmap</a
	  ></p
	></div
      ><div id="al_draw_pixel"
      ><h2
	><a href="#TOC"
	  >al_draw_pixel</a
	  ></h2
	><pre
	><code
	  >void al_draw_pixel(float x, float y, ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Draws a single pixel at x, y. This function, unlike <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  >, does blending and, unlike <a href="graphics.html#al_put_blended_pixel"
	  >al_put_blended_pixel</a
	  >, respects the transformations. This function can be slow if called often; if you need to draw a lot of pixels consider using the primitives addon.</p
	><ul
	><li
	  >x - destination x</li
	  ><li
	  >y - destination y</li
	  ><li
	  >color - color of the pixel</li
	  ></ul
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  >, <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  ></p
	></div
      ><div id="al_draw_rotated_bitmap"
      ><h2
	><a href="#TOC"
	  >al_draw_rotated_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_draw_rotated_bitmap(ALLEGRO_BITMAP *bitmap,
   float cx, float cy, float dx, float dy, float angle, int flags)
</code
	  ></pre
	><p
	>Draws a rotated version of the given bitmap to the target bitmap. The bitmap is rotated by 'angle' radians clockwise.</p
	><p
	>The point at cx/cy inside the bitmap will be drawn at dx/dy and the bitmap is rotated around this point.</p
	><ul
	><li
	  >cx - center x</li
	  ><li
	  >cy - center y</li
	  ><li
	  >dx - destination x</li
	  ><li
	  >dy - destination y</li
	  ><li
	  >angle - angle by which to rotate</li
	  ><li
	  >flags - same as for <a href="graphics.html#al_draw_bitmap"
	    >al_draw_bitmap</a
	    ></li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_draw_bitmap"
	  >al_draw_bitmap</a
	  >, <a href="graphics.html#al_draw_bitmap_region"
	  >al_draw_bitmap_region</a
	  >, <a href="graphics.html#al_draw_scaled_bitmap"
	  >al_draw_scaled_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_scaled_bitmap"
	  >al_draw_rotated_scaled_bitmap</a
	  ></p
	></div
      ><div id="al_draw_rotated_scaled_bitmap"
      ><h2
	><a href="#TOC"
	  >al_draw_rotated_scaled_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_draw_rotated_scaled_bitmap(ALLEGRO_BITMAP *bitmap,
   float cx, float cy, float dx, float dy, float xscale, float yscale,
   float angle, int flags)
</code
	  ></pre
	><p
	>Like <a href="graphics.html#al_draw_rotated_bitmap"
	  >al_draw_rotated_bitmap</a
	  >, but can also scale the bitmap.</p
	><p
	>The point at cx/cy in the bitmap will be drawn at dx/dy and the bitmap is rotated and scaled around this point.</p
	><ul
	><li
	  >cx - center x</li
	  ><li
	  >cy - center y</li
	  ><li
	  >dx - destination x</li
	  ><li
	  >dy - destination y</li
	  ><li
	  >xscale - how much to scale on the x-axis (e.g. 2 for twice the size)</li
	  ><li
	  >yscale - how much to scale on the y-axis</li
	  ><li
	  >angle - angle by which to rotate</li
	  ><li
	  >flags - same as for <a href="graphics.html#al_draw_bitmap"
	    >al_draw_bitmap</a
	    ></li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_draw_bitmap"
	  >al_draw_bitmap</a
	  >, <a href="graphics.html#al_draw_bitmap_region"
	  >al_draw_bitmap_region</a
	  >, <a href="graphics.html#al_draw_scaled_bitmap"
	  >al_draw_scaled_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_bitmap"
	  >al_draw_rotated_bitmap</a
	  ></p
	></div
      ><div id="al_draw_scaled_bitmap"
      ><h2
	><a href="#TOC"
	  >al_draw_scaled_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_draw_scaled_bitmap(ALLEGRO_BITMAP *bitmap,
   float sx, float sy, float sw, float sh,
   float dx, float dy, float dw, float dh, int flags)
</code
	  ></pre
	><p
	>Draws a scaled version of the given bitmap to the target bitmap.</p
	><ul
	><li
	  >sx - source x</li
	  ><li
	  >sy - source y</li
	  ><li
	  >sw - source width</li
	  ><li
	  >sh - source height</li
	  ><li
	  >dx - destination x</li
	  ><li
	  >dy - destination y</li
	  ><li
	  >dw - destination width</li
	  ><li
	  >dh - destination height</li
	  ><li
	  >flags - same as for <a href="graphics.html#al_draw_bitmap"
	    >al_draw_bitmap</a
	    ></li
	  ></ul
	><p
	>See also: <a href="graphics.html#al_draw_bitmap"
	  >al_draw_bitmap</a
	  >, <a href="graphics.html#al_draw_bitmap_region"
	  >al_draw_bitmap_region</a
	  >, <a href="graphics.html#al_draw_rotated_bitmap"
	  >al_draw_rotated_bitmap</a
	  >, <a href="graphics.html#al_draw_rotated_scaled_bitmap"
	  >al_draw_rotated_scaled_bitmap</a
	  >,</p
	></div
      ><div id="al_get_target_bitmap"
      ><h2
	><a href="#TOC"
	  >al_get_target_bitmap</a
	  ></h2
	><pre
	><code
	  >ALLEGRO_BITMAP *al_get_target_bitmap(void)
</code
	  ></pre
	><p
	>Return the target bitmap of the current display.</p
	><p
	>See also: <a href="graphics.html#al_set_target_bitmap"
	  >al_set_target_bitmap</a
	  ></p
	></div
      ><div id="al_put_pixel"
      ><h2
	><a href="#TOC"
	  >al_put_pixel</a
	  ></h2
	><pre
	><code
	  >void al_put_pixel(int x, int y, ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Draw a single pixel on the target bitmap. This operation is slow on non-memory bitmaps. Consider locking the bitmap if you are going to use this function multiple times on the same bitmap. This function is not affected by neither the transformations nor the color blenders.</p
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  >, <a href="graphics.html#al_get_pixel"
	  >al_get_pixel</a
	  >, <a href="graphics.html#al_put_blended_pixel"
	  >al_put_blended_pixel</a
	  ></p
	></div
      ><div id="al_put_blended_pixel"
      ><h2
	><a href="#TOC"
	  >al_put_blended_pixel</a
	  ></h2
	><pre
	><code
	  >void al_put_blended_pixel(int x, int y, ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Like <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  >, but the pixel color is blended using the current blenders before being drawn.</p
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  >, <a href="graphics.html#al_put_pixel"
	  >al_put_pixel</a
	  ></p
	></div
      ><div id="al_set_target_bitmap"
      ><h2
	><a href="#TOC"
	  >al_set_target_bitmap</a
	  ></h2
	><pre
	><code
	  >void al_set_target_bitmap(ALLEGRO_BITMAP *bitmap)
</code
	  ></pre
	><p
	>Select the bitmap to which all subsequent drawing operations in the calling thread will draw. Select the backbuffer (see <a href="display.html#al_get_backbuffer"
	  >al_get_backbuffer</a
	  >) to return to drawing to the screen normally.</p
	><p
	>OpenGL note:</p
	><p
	>Framebuffer objects (FBOs) allow OpenGL to directly draw to a bitmap, which is very fast. However, each created FBO needs additional resources, therefore an FBO is not automatically assigned to each non-memory bitmap when it is created (as is done with textures).</p
	><p
	>When using an OpenGL display, only if all of the following conditions are met an FBO will be created for the bitmap:</p
	><ul
	><li
	  >The GL_EXT_framebuffer_object OpenGL extension is available.</li
	  ><li
	  >The bitmap is not a memory bitmap.</li
	  ><li
	  >The bitmap is not currently locked.</li
	  ></ul
	><p
	>Once created, the FBO is kept around until the bitmap is destroyed or you explicitely call <a href="opengl.html#al_remove_opengl_fbo"
	  >al_remove_opengl_fbo</a
	  > on the bitmap.</p
	><p
	>In the following example, no FBO will be created:</p
	><pre
	><code
	  >lock = al_lock_bitmap(bitmap);
al_set_target_bitmap(bitmap);
al_put_pixel(x, y, color);
al_unlock_bitmap(bitmap);
</code
	  ></pre
	><p
	>The above allows using al_put_pixel on a locked bitmap without creating an FBO.</p
	><p
	>In this example an FBO is created however:</p
	><pre
	><code
	  >al_set_target_bitmap(bitmap);
al_draw_line(x1, y1, x2, y2, color, 0);
</code
	  ></pre
	><p
	>And an OpenGL command will be used to directly draw the line into the bitmap's associated texture.</p
	><p
	>See also: <a href="graphics.html#al_get_target_bitmap"
	  >al_get_target_bitmap</a
	  ></p
	></div
      ></div
    ><div id="blending-modes"
    ><h1
      ><a href="#TOC"
	>Blending modes</a
	></h1
      ><div id="al_get_blender"
      ><h2
	><a href="#TOC"
	  >al_get_blender</a
	  ></h2
	><pre
	><code
	  >void al_get_blender(int *op, int *src, int *dst, ALLEGRO_COLOR *color)
</code
	  ></pre
	><p
	>Returns the active blender for the current thread. You can pass NULL for values you are not interested in.</p
	><p
	>See also: <a href="graphics.html#al_set_blender"
	  >al_set_blender</a
	  >, <a href="graphics.html#al_get_separate_blender"
	  >al_get_separate_blender</a
	  ></p
	></div
      ><div id="al_get_separate_blender"
      ><h2
	><a href="#TOC"
	  >al_get_separate_blender</a
	  ></h2
	><pre
	><code
	  >void al_get_separate_blender(int *op, int *src, int *dst,
   int *alpha_op, int *alpha_src, int *alpha_dst, ALLEGRO_COLOR *color)
</code
	  ></pre
	><p
	>Returns the active blender for the current thread. You can pass NULL for values you are not interested in.</p
	><p
	>See also: <a href="graphics.html#al_set_separate_blender"
	  >al_set_separate_blender</a
	  >, <a href="graphics.html#al_get_blender"
	  >al_get_blender</a
	  ></p
	></div
      ><div id="al_set_blender"
      ><h2
	><a href="#TOC"
	  >al_set_blender</a
	  ></h2
	><pre
	><code
	  >void al_set_blender(int op, int src, int dst, ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Sets the function to use for blending for the current thread.</p
	><p
	>Blending means, the source and destination colors are combined in drawing operations.</p
	><p
	>Assume the source color (e.g. color of a rectangle to draw, or pixel of a bitmap to draw) is given as its red/green/blue/alpha components (if the bitmap has no alpha it always is assumed to be fully opaque, so 255 for 8-bit or 1.0 for floating point): <em
	  >sr, sg, sb, sa</em
	  >. And this color is drawn to a destination, which already has a color: <em
	  >dr, dg, db, da</em
	  >.</p
	><p
	>The conceptional formula used by Allegro to draw any pixel then depends on the <code
	  >op</code
	  > parameter:</p
	><ul
	><li
	  ><p
	    >ALLEGRO_ADD</p
	    ><pre
	    ><code
	      > r = dr * dst + sr * src
 g = dg * dst + sg * src
 b = db * dst + sb * src
 a = da * dst + sa * src
</code
	      ></pre
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_DEST_MINUS_SRC</p
	    ><pre
	    ><code
	      > r = dr * dst - sr * src
 g = dg * dst - sg * src
 b = db * dst - sb * src
 a = da * dst - sa * src
</code
	      ></pre
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_SRC_MINUS_DEST</p
	    ><pre
	    ><code
	      > r = sr * src - dr * dst
 g = sg * src - dg * dst
 b = sb * src - db * dst
 a = sa * src - da * dst
</code
	      ></pre
	    ></li
	  ></ul
	><p
	>Valid values for <code
	  >src</code
	  > and <code
	  >dst</code
	  > passed to this function are</p
	><ul
	><li
	  ><p
	    >ALLEGRO_ZERO</p
	    ><pre
	    ><code
	      > src = 0
 dst = 0
</code
	      ></pre
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_ONE</p
	    ><pre
	    ><code
	      > src = 1
 dst = 1
</code
	      ></pre
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_ALPHA</p
	    ><pre
	    ><code
	      > src = sa
 dst = sa
</code
	      ></pre
	    ></li
	  ><li
	  ><p
	    >ALLEGRO_INVERSE_ALPHA</p
	    ><pre
	    ><code
	      > src = 1 - sa
 dst = 1 - sa
</code
	      ></pre
	    ></li
	  ></ul
	><p
	>The color parameter specifies the blend color, it is multipled with the source color before the above blending operation.</p
	><p
	>Blending examples:</p
	><p
	>So for example, to restore the default of using alpha blending, you would use (pseudo code)</p
	><pre
	><code
	  >al_set_blender(ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA, {1, 1, 1, 1})
</code
	  ></pre
	><p
	>If in addition you want to draw half transparently</p
	><pre
	><code
	  >al_set_blender(ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA, {1, 1, 1, 0.5})
</code
	  ></pre
	><p
	>Additive blending would be achieved with</p
	><pre
	><code
	  >al_set_blender(ALLEGRO_ONE, ALLEGRO_ONE, {1, 1, 1, 1})
</code
	  ></pre
	><p
	>Copying the source to the destination (including alpha) unmodified</p
	><pre
	><code
	  >al_set_blender(ALLEGRO_ONE, ALLEGRO_ZERO, {1, 1, 1, 1})
</code
	  ></pre
	><p
	>See also: <a href="graphics.html#al_set_separate_blender"
	  >al_set_separate_blender</a
	  >, <a href="graphics.html#al_get_blender"
	  >al_get_blender</a
	  ></p
	></div
      ><div id="al_set_separate_blender"
      ><h2
	><a href="#TOC"
	  >al_set_separate_blender</a
	  ></h2
	><pre
	><code
	  >void al_set_separate_blender(int op, int src, int dst,
   int alpha_op, int alpha_src, int alpha_dst, ALLEGRO_COLOR color)
</code
	  ></pre
	><p
	>Like <a href="graphics.html#al_set_blender"
	  >al_set_blender</a
	  >, but allows specifying a separate blending operation for the alpha channel.</p
	><p
	>See also: <a href="graphics.html#al_set_blender"
	  >al_set_blender</a
	  >, <a href="graphics.html#al_get_blender"
	  >al_get_blender</a
	  >, <a href="graphics.html#al_get_separate_blender"
	  >al_get_separate_blender</a
	  ></p
	></div
      ></div
    ><div id="clipping"
    ><h1
      ><a href="#TOC"
	>Clipping</a
	></h1
      ><div id="al_get_clipping_rectangle"
      ><h2
	><a href="#TOC"
	  >al_get_clipping_rectangle</a
	  ></h2
	><pre
	><code
	  >void al_get_clipping_rectangle(int *x, int *y, int *w, int *h)
</code
	  ></pre
	><p
	>Gets the clipping rectangle of the target bitmap.</p
	><p
	>See also: <a href="graphics.html#al_set_clipping_rectangle"
	  >al_set_clipping_rectangle</a
	  ></p
	></div
      ><div id="al_set_clipping_rectangle"
      ><h2
	><a href="#TOC"
	  >al_set_clipping_rectangle</a
	  ></h2
	><pre
	><code
	  >void al_set_clipping_rectangle(int x, int y, int width, int height)
</code
	  ></pre
	><p
	>Set the region of the target bitmap or display that pixels get clipped to. The default is to clip pixels to the entire bitmap.</p
	><p
	>See also: <a href="graphics.html#al_get_clipping_rectangle"
	  >al_get_clipping_rectangle</a
	  ></p
	></div
      ></div
    ><div id="graphics-utility-functions"
    ><h1
      ><a href="#TOC"
	>Graphics utility functions</a
	></h1
      ><div id="al_convert_mask_to_alpha"
      ><h2
	><a href="#TOC"
	  >al_convert_mask_to_alpha</a
	  ></h2
	><pre
	><code
	  >void al_convert_mask_to_alpha(ALLEGRO_BITMAP *bitmap, ALLEGRO_COLOR mask_color)
</code
	  ></pre
	><p
	>Convert the given mask color to an alpha channel in the bitmap. Can be used to convert older 4.2-style bitmaps with magic pink to alpha-ready bitmaps.</p
	><p
	>See also: <a href="graphics.html#allegro_color"
	  >ALLEGRO_COLOR</a
	  ></p
	></div
      ></div
    ><div id="deferred-drawing"
    ><h1
      ><a href="#TOC"
	>Deferred drawing</a
	></h1
      ><div id="al_hold_bitmap_drawing"
      ><h2
	><a href="#TOC"
	  >al_hold_bitmap_drawing</a
	  ></h2
	><pre
	><code
	  >void al_hold_bitmap_drawing(bool hold)
</code
	  ></pre
	><p
	>Enables or disables deferred bitmap drawing. This allows for efficient drawing of many bitmaps that share a parent bitmap, such as sub-bitmaps from a tilesheet or simply identical bitmaps. Drawing bitmaps that do not share a parent is less efficient, so it is advisable to stagger bitmap drawing calls such that the parent bitmap is the same for large number of those calls. While deferred bitmap drawing is enabled, the only functions that can be used are the bitmap drawing functions and font drawing functions. Changing the state such as the blending modes will result in undefined behaviour. However, changing the blending color, but keeping the blending modes the same will work as expected.</p
	><p
	>No drawing is guaranteed to take place until you disable the hold. Thus, the idiom of this function's usage is to enable the deferred bitmap drawing, draw as many bitmaps as possible, taking care to stagger bitmaps that share parent bitmaps, and then disable deferred drawing. As mentioned above, this function also works with bitmap and truetype fonts, so if multiple lines of text need to be drawn, this function can speed things up.</p
	><p
	>See also: <a href="graphics.html#al_is_bitmap_drawing_held"
	  >al_is_bitmap_drawing_held</a
	  ></p
	></div
      ><div id="al_is_bitmap_drawing_held"
      ><h2
	><a href="#TOC"
	  >al_is_bitmap_drawing_held</a
	  ></h2
	><pre
	><code
	  >bool al_is_bitmap_drawing_held(void)
</code
	  ></pre
	><p
	>Returns whether the deferred bitmap drawing mode is turned on or off.</p
	><p
	>See also: <a href="graphics.html#al_hold_bitmap_drawing"
	  >al_hold_bitmap_drawing</a
	  ></p
	></div
      ></div
    ></td>
</tr>
</table>


<p>
Last updated: 2010-04-01 08:44:53 UTC
</p>
</body
  ></html
>

